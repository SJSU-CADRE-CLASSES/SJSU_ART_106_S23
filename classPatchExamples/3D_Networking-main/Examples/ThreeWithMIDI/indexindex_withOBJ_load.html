<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style>
			body { margin: 0; }
		</style>
	</head>

<body>

	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

	<script type="importmap">
		{
			"imports": {
				"three": "./node_modules/three/build/three.module.js",
				"three/addons/": "./jsm/"
			}
		}
	</script>  


	  <script type="module">
	  
	  	import * as THREE from './node_modules/three/build/three.module.js';
		import { OrbitControls } from './node_modules/three/examples/jsm/controls/OrbitControls.js';
		//import { OBJLoader } from './node_modules/three/examples/jsm/loaders/OBJLoader.js';
		import { GLTFLoader } from './node_modules/three/examples/jsm/loaders/GLTFLoader.js';
		import { RGBELoader } from './node_modules/three/examples/jsm/loaders/RGBELoader.js';
	  
		let container;
		let camera, scene, renderer;
		let mouseX = 0, mouseY = 0;
		let windowHalfX = window.innerWidth / 2;
		let windowHalfY = window.innerHeight / 2;
		let object;
		
		init();
		animate();

		function init() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.position.z = 5;

			const ambientLight = new THREE.AmbientLight( 0xcccccc, 0.9 );
			scene.add( ambientLight );

			const pointLight = new THREE.PointLight( 0xffffff, 1.8 );
			camera.add( pointLight );

			new RGBELoader()
					.load( 'royal_esplanade_1k.hdr', function ( texture ) {
						texture.mapping = THREE.EquirectangularReflectionMapping;
						scene.background = texture;
						scene.environment = texture;
						render();
						const loader = new GLTFLoader();
						loader.load( 'env.glb', function ( gltf ) {
							scene.add( gltf.scene );
							render();
						} );
					} );

			// function loadModel() {
			// 	object.traverse( function ( child ) {
			// 		if ( child.isMesh ) child.material.map = texture;
			// 	} );
			// 	//object.position.y = 0;
			// 	scene.add( object );
			// }
			
			// const manager = new THREE.LoadingManager( loadModel );
			// const textureLoader = new THREE.TextureLoader( manager );
			// const texture = textureLoader.load( 'texture.jpg' );

			// function onProgress( xhr ) {
			// 	if ( xhr.lengthComputable ) {
			// 		const percentComplete = xhr.loaded / xhr.total * 100;
			// 		console.log( 'model ' + Math.round( percentComplete, 2 ) + '% downloaded' );
			// 	}
			// }

			// function onError() {}
			// 	const loader = new OBJLoader( manager );
			// 	loader.load( 'env.obj', function ( obj ) {
			// 	object = obj;
			// }, onProgress, onError );

			// const material_line = new THREE.LineBasicMaterial( { color: 0x0000ff } );
			// const points = [];
			// points.push( new THREE.Vector3( - 10, 0, 0 ) );
			// points.push( new THREE.Vector3( 0, 10, 0 ) );
			// points.push( new THREE.Vector3( 10, 0, 0 ) );
			// const geometry_line = new THREE.BufferGeometry().setFromPoints( points );
			// const line = new THREE.Line( geometry_line, material_line );
			// scene.add( line )

			// const geometry = new THREE.BoxGeometry( 1, 1, 1 );
			// const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			// const cube = new THREE.Mesh( geometry, material );
			// scene.add( cube );
		
			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = 1;
			renderer.outputEncoding = THREE.sRGBEncoding;
			document.body.appendChild( renderer.domElement );

			const controls = new OrbitControls( camera, renderer.domElement );
			controls.addEventListener( 'change', render ); // use if there is no animation loop
			controls.minDistance = 2;
			controls.maxDistance = 10;
			controls.target.set( 0, 0, - 0.2 );
			controls.update();

			window.addEventListener( 'resize', onWindowResize );
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
			render();
		}

		function onDocumentMouseMove( event ) {
			mouseX = ( event.clientX - windowHalfX ) / 2;
			mouseY = ( event.clientY - windowHalfY ) / 2;
		}

		function animate() {
			requestAnimationFrame( animate );
			//renderer.render( scene, camera );
			render();
		}

		function render() {
			renderer.render( scene, camera );
		}

	  </script>
</body>
</html>